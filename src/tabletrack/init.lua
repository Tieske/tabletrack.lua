--- #tabletrack
--
-- A module to help transparently track table accesses.
--
-- Usecase: renaming a core structure and every field inside it for a large
-- codebase. Hence this utility was created to track every access, as well
-- as catching potential typos in fieldnames.
--
-- Limitation: the implementation is limited by the possibilities of
-- intercepting `__index` and `__newindex` meta-methods. And hence not every
-- access might initially be caught.
--
-- @copyright 2018 Thijs Schreijer
-- @author Thijs Schreijer
-- @license MIT


local DEFAULT_FILENAME = "./tabletrack.stats.out"

local _M = {}


-- default metamethods, doing the default Lua thing
local default_index = function(self, key)
  return rawget(self, key)  -- default behavior
end

local default_newindex = function(self, key, value)
  return rawset(self, key, value)  -- default behavior
end

-- replacement metamethods implementing the tracker callback
local function track_index(self, key)
  local tracker = getmetatable(self).__tracker
  local track_data = tracker[self]
  if (not track_data) and tracker.__track_all then
    -- we're not tracking, but we should
    local opts = tracker.__track_all
    _M.track_access(self, opts)
    track_data = tracker[self]
  end
  local proxy
  if track_data then
    -- we're tracking this table
    local opts = track_data.opts
    proxy = track_data.proxy
    opts.cb(opts, "get", key)
  end
  return tracker.__original_index(proxy or self, key)
end

local function track_newindex(self, key, value)
  local tracker = getmetatable(self).__tracker
  local track_data = tracker[self]
  if (not track_data) and tracker.__track_all then
    -- we're not tracking, but we should
    local opts = tracker.__track_all
    _M.track_access(self, opts)
    track_data = tracker[self]
  end
  local proxy
  if track_data then
    -- we're tracking this table
    local opts = track_data.opts
    proxy = track_data.proxy
    opts.cb(opts, "set", key)
  end
  return tracker.__original_newindex(proxy or self, key, value)
end


--- Retuns a single line stack-trace.
-- Call this from the tracker callback function to get the proper stacktrace.
-- @param opts the options table
-- @return a single line stacktrace string
function _M.get_trace(opts)
  local tb = debug.traceback()
  -- find the LAST 'tabletrack.lua', then continue until a newline, then
  -- skip any leading whitespace, and finally grab everything after that.
  tb = tb:match("^.+tabletrack%/init%.lua.-\n%s*(.-)$")
  if opts.full_trace then
    -- now separate lines by a backslash (while skipping whitespace)
    tb = tb:gsub("%s*\n%s*", [[ \ ]])
  else
    -- only grab the last call from the stack trace
    tb = tb:match("^(.-)%s*\n")
  end
  return tb
end



-- the access callback
local function track_cb(opts, call_type, key)
  local tb = nil
  if opts.filename then
    -- let's try and open the file
    local file = io.open(opts.filename, "a")
    if not file then
      -- we failed to append, open for read to check existence
      file = io.open(opts.filename)
      if file then
        -- could not open to append, but was able to open for read...
        file:close()
        error("cannot open file for writing:" .. tostring(opts.filename))
      end
      -- couldn't open for reading either, so probably doesn't exist, let's
      -- open for writing to create it
      file = io.open(opts.filename, "w")
      if not file then
        error("cannot open file for writing:" .. tostring(opts.filename))
      end
    end
    tb = tb or _M.get_trace(opts)
    file:write(opts.name, "\n")
    file:write(call_type, "\n")
    file:write(key, "\n")
    file:write(tb, "\n")
    file:close()
  end
end

--- parses a log file with data into a Lua table structure.
-- It only parses the format as generated by the default callback.
-- @param filename (optional) the name of the logfile to parse (default
-- "./table_tracker_output")
-- @return table with the parsed results
function _M.parse_file(filename)
  filename = filename or DEFAULT_FILENAME
  local list = {}
  local file = assert(io.open(filename))
  local name = file:read()
  while name do
    local call_type = assert(file:read())
    local key = assert(file:read())
    local trace = assert(file:read())

    local name_entry = list[name]
    if not name_entry then
      name_entry = {}
      list[name] = name_entry
    end

    local key_entry = name_entry[key]
    if not key_entry then
      key_entry = {}
      name_entry[key] = key_entry
    end

    local type_entry = key_entry[call_type]
    if not type_entry then
      type_entry = {}
      key_entry[call_type] = type_entry
    end

    type_entry[trace] = (type_entry[trace] or 0) + 1

    -- move on to next entry
    name = file:read()
  end
  file:close()
  return list
end



--- enables tracking table access.
-- @param t table to track access to
-- @param opts table with options
-- @return t, the table to track
-- @usage
-- local t = track_access({}, {
--   name = "t-name", -- table name as a unique identifier, default: tostring(t)
--   cb = function(opts, type, key)          -- callback on access
--          -- opts = options table
--          -- type = access type: "get", "set", "exists"
--          -- key = the key being accesses
--   end,
--   proxy = nil,      -- using a proxy drops iterators, but catches more
--   full_trace = nil, -- full stack track, or only the last call
--   -- options for the default callback:
--   filename = "./tabletrack.stats.out"  -- filename where to store the data
-- })
function _M.track_access(t, opts)
  assert(type(t) == "table", "expected a type 'table'")

  -- does this table already have a metatable?
  local mt = getmetatable(t)
  if not mt then
    -- No metatable yet, so create a stub one
    mt = {}
    setmetatable(t, mt)
  end

  -- we have a MT now, set options. Since MT's can be shared, we store
  -- the options indexed by 'self', but weak, so we can still GC.
  if not mt.__tracker then
    mt.__tracker = setmetatable({}, { __mode = "k" })
  else
    if mt.__tracker[t] then
      return error("cannot track an already tracked table", 2)
    end
  end

  -- store the options, and replace the metamethods
  opts = opts or {}
  local proxy = opts.proxy and {} or nil

  mt.__tracker[t] = {
    opts = opts,
    proxy = proxy,
  }

  opts.name = opts.name or tostring(t)
  opts.filename = opts.filename or DEFAULT_FILENAME
  opts.cb = opts.cb or track_cb
  if not mt.__tracker.__original_index then
    mt.__tracker.__original_index = mt.__index or default_index
    mt.__tracker.__original_newindex = mt.__newindex or default_newindex

    mt.__index = track_index
    mt.__newindex = track_newindex

    if type(mt.__tracker.__original_index) == "table" then
      -- wrap the __index lookup table in a function
      local oi = mt.__tracker.__original_index
      mt.__tracker.__original_index = function(self, key)
        return oi[key]
      end
    end
  end

  -- record existing entries
  for k, v in pairs(t) do
    opts.cb(opts, "exists", k)
    if proxy then
      -- move the value into the proxy table
      proxy[k] = v
      t[k] = nil
    end
  end

  return t
end


--- Track a type, by tracking its metatable.
-- Same as `track_access` except that in this case the metatable is provided,
-- such that all instances using this metatable will be tracked.
-- @param mt the metatable whose instances to track
-- @param opts table with options, see `track_access`
-- @return the metatable
function _M.track_type(mt, opts)
  local t = {}
  _M.track_access(setmetatable(t, mt), opts)
  -- now copy the options table to the generic options for track_all
  mt.__tracker.__track_all = mt.__tracker[t].opts
  return mt
end

return _M
